## Plpgsql

PL/pgsql é uma linguagem procedural que permite e a criação de funções, procedimentos e triggers. 

### Funções

Funções são blocos de código que encapsulam lógica de negócio para reutilização, podem receber parametros, fazer ações e retornar valores.

```sql
CREATE OR REPLACE FUNCTION increment(i INT) RETURN INT AS $$
BEGIN
    RETURN i + 1;
END;
$$ LANGUAGE plpgsql;
```

### Procedimentos

Procedimentos é semelhante a uma função mas não retorna um valor e são invocados com `CALL`.

```sql
CREATE OR REPLACE PROCEDURE update_salary(emp_id INT, percent_raise NUMERIC) AS $$
BEGIN
    UPDATE employees SET salary = salary * salary * percent_raise WHERE id = emp_id;
END;
$$ LANGUAGE plpgsql;
```

Para chamar um procedimento:

```sql
CALL update_salary(1, 0.1); -- 10% raise
```

### Triggers

Triggers são um tipo especial de procedimento que são executados de forma automática quando acontece uma certa ação numa tabela específica, como um insert update ou delete.

```sql
CREATE OR REPLACE FUNCTION audit_changes() RETURNS TRIGGER AS $$
BEGIN 
    IF TG_OP 

```

```sql
CREATE TABLE IF NOT EXISTS partida(
    nr          INTEGER      NOT NULL,
    id_jogo     ALPHANUMERIC NOT NULL REFERENCES jogo(id) ON DELETE CASCADE,
    data_inicio TIMESTAMP    NOT NULL,
    data_fim    TIMESTAMP,
    nome_regiao VARCHAR(50)  NOT NULL REFERENCES regiao(nome),

    UNIQUE (id_jogo, nr),

    CONSTRAINT date_constraint CHECK(data_inicio < data_fim),

    CONSTRAINT pk_partida PRIMARY KEY(id_jogo, nr)
);
```

- Conta quantas partidas foram terminadas no ultimo mês
```sql
CREATE OR REPLACE FUNCTION count_matches() RETURNS INT AS $$
BEGIN
    RETURN (SELECT count(p.data_fim) FROM partida p JOIN partida_multijogador pm ON p.id_jogo=pm.id_jogo AND p.nr=pm.nr WHERE data_fim > now() - interval '1 month' AND pm.estado ILIKE 'terminada');
END;
$$ LANGUAGE plpgsql;
```

```sql
CREATE TABLE IF NOT EXISTS regiao(
    nome VARCHAR(50) PRIMARY KEY
);

-- Jogador
CREATE TABLE IF NOT EXISTS jogador(
    id          INTEGER     PRIMARY KEY
        GENERATED BY DEFAULT AS IDENTITY,
    username    VARCHAR(50) NOT NULL,
    email       EMAIL       NOT NULL,
    estado      VARCHAR(20) DEFAULT 'ativo',
    nome_regiao VARCHAR(50) NOT NULL        REFERENCES regiao(nome) ON DELETE CASCADE,

    UNIQUE(username),
    UNIQUE(email),
    UNIQUE(username, email),

    CONSTRAINT estado_jogador CHECK(estado ~* '^(ativo|banido|inativo)$')
);
```


Criar os mecanismos que permitam criar o jogador, dados os seus email, região e username, desativar e banir o jogador;
email regiao username
1 mecanismo para criar

```sql
CREATE OR REPLACE FUNCTION create_player(playerEmail EMAIL, playerRegiao VARCHAR, playerUsername VARCHAR) RETURNS INT as $$
DECLARE
    obtainedId INT;
BEGIN
    IF NOT EXISTS (SELECT * FROM regiao WHERE nome = playerRegiao) THEN 
        RAISE EXCEPTION 'Região não existe';
    END IF;
    INSERT INTO jogador(email, nome_regiao, username) VALUES (playerEmail, playerRegiao, playerUsername);
    SELECT id into obtainedId FROM jogador WHERE email = playerEmail;
    RETURN obtainedId
END; 
$$ LANGUAGE plpgsql;
```

OR 

```sql
CREATE OR REPLACE FUNCTION create_player(playerEmail EMAIL, playerRegiao VARCHAR, playerUsername VARCHAR) RETURNS INT as $$
BEGIN
    IF NOT EXISTS (SELECT * FROM regiao WHERE nome = playerRegiao) THEN 
        RAISE EXCEPTION 'Região não existe';
    END IF;
    RETURN (INSERT INTO jogador(email, nome_regiao, username) VALUES (playerEmail, playerRegiao, playerUsername) RETURNING id);
END; 
$$ LANGUAGE plpgsql;
```

1 mecanismo para desativar

```sql
CREATE OR REPLACE PROCEDURE deactivate_player(playerUsername VARCHAR) as $$
BEGIN
    IF NOT EXISTS(SELECT * FROM jogador WHERE username = playerUsername) THEN
        RAISE EXCEPTION 'Jogador does not exist';
    END IF;
    -- If it get's here means it exists
    UPDATE jogador SET estado = 'inativo' WHERE username = playerUsername;
END;
$$ LANGUAGE plpgsql;
```

1 mecanismo para banir

```sql
CREATE OR REPLACE PROCEDURE ban_player(playerUsername VARCHAR) as $$
BEGIN
    IF NOT EXISTS(SELECT * FROM jogador WHERE username = playerUsername) THEN
        RAISE EXCEPTION 'Jogador does not exist';
    END IF;
    -- If it get's here means it exists
    UPDATE jogador SET estado = 'banido' WHERE username = playerUsername;
END;
$$ LANGUAGE plpgsql;
```

```sql
CREATE OR REPLACE PROCEDURE set_player_status(playerUsername VARCHAR, playerNewStatus VARCHAR) as $$
BEGIN
    IF NOT EXISTS(SELECT * FROM jogador WHERE username = playerUsername) THEN
        RAISE EXCEPTION 'Jogador does not exist';
    END IF;
    -- If it get's here means it exists
      UPDATE jogador SET estado = playerNewStatus WHERE username = playerUsername;
END;
$$ LANGUAGE plpgsql;
```

## TODO

- understand cursors
- understand pessimistic and optimistic locking 
- transações